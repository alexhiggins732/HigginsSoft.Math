/*
 Copyright (c) 2023 HigginsSoft
 Written by Alexander Higgins https://github.com/alexhiggins732/ 
 
 Source code for this software can be found at https://github.com/alexhiggins732/HigginsSoft.Math
 
 This software is licensce under GNU General Public License version 3 as described in the LICENSE
 file at https://github.com/alexhiggins732/HigginsSoft.Math/LICENSE
 
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

*/

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.


// Some routines inspired by the Stanford Bit Twiddling Hacks by Sean Eron Anderson:
// http://graphics.stanford.edu/~seander/bithacks.html

#define TARGET_64BIT

using static MathGmp.Native.gmp_lib;
using MathGmp.Native;
using System.Threading;
using System.Diagnostics;
using System.Numerics;
using System.Security.Cryptography;
using System.Linq.Expressions;
using System.Reflection;

namespace HigginsSoft.Math.Lib
{
    public partial class MathLib
    {

        public const int PRP_ERROR = -1;
        public const int PRP_COMPOSITE = 0;
        public const int PRP_PRP = 1;
        public const int PRP_PRIME = 2;


        public enum PrimalityType
        {
            Error = PRP_ERROR,
            UNKNOWN = -2,
            Composite = PRP_COMPOSITE,
            ProbablePrime = PRP_PRP,
            Prime = PRP_PRIME,
        }

        public static bool IsBSmooth(int n, int[] primes)
            => IsBSmooth(n, primes, primes.Max());
        public static bool IsBSmooth(int n, int[] primes, int MaxPrime)
        {
            bool result = n < MaxPrime;
            if (!result)
            {
                for (var i = 0; n > MaxPrime && i < primes.Length; i++)
                {
                    var p = primes[i];
                    while (n % p == 0)
                        n /= p;
                }
            }
            return n <= MaxPrime;
        }

        public static bool IsBSmooth(int n, int[] primes, int MaxPrime, out int gf2Mask)
        {
            gf2Mask = 0;
            int mask = 1;

            for (var i = 0; n > 1 && i < primes.Length; i++)
            {
                var p = primes[i];
                while (n % p == 0)
                {
                    gf2Mask = gf2Mask ^ mask;
                    n /= p;
                }
                mask <<= 1;
            }

            return n <= MaxPrime;
        }

        public static bool IsQuadratic(int n, int p)
        {
            if (p == 2) return true;
            return PowerMod(n, p >> 1, p) == 1;
        }

        static void gordon(int bits, mpz_t p, gmp_randstate_t gmp_randstate)
        {
            //find a random strong prime of size 'bits'
            //follows the Handbook of applied cryptography
            /*
            SUMMARY: a strong prime p is generated.
            1. Generate two large random primes s and t of roughly equal bitlength (see Note 4.54).
            2. Select an integer i0. Find the first prime in the sequence 2it + 1, for i = i0; i0 +
                1; i0 + 2; : : : (see Note 4.54). Denote this prime by r = 2it+ 1.
            3. Compute p0 = 2(sr-2 mod r)s - 1.
            4. Select an integer j0. Find the first prime in the sequence p0 +2jrs, for j = j0; j0 +
                1; j0 + 2; : : : (see Note 4.54). Denote this prime by p = p0 + 2jrs.
            5. Return(p).

          4.54 Note (implementing Gordon’s algorithm)
            (i) The primes s and t required in step 1 can be probable primes generated by Algorithm
            4.44. TheMiller-Rabin test (Algorithm 4.24) can be used to test each candidate
            for primality in steps 2 and 4, after ruling out candidates that are divisible by a small
            prime less than some boundB. See Note 4.45 for guidance on selecting B. Since the
            Miller-Rabin test is a probabilistic primality test, the output of this implementation
            of Gordon’s algorithm is a probable prime.
            (ii) By carefully choosing the sizes of primes s, t and parameters i0, j0, one can control
            the exact bitlength of the resulting prime p. Note that the bitlengths of r and s will
            be about half that of p, while the bitlength of t will be slightly less than that of r.
            */

            uint i, j, n_words;
            mp_bitcnt_t s_len;
            mpz_t s = new(), t = new(), r = new(), tmp = new(), tmp2 = new(), p0 = new();

            mpz_init(s);
            mpz_init(t);
            mpz_init(r);
            mpz_init(tmp);
            mpz_init(tmp2);
            mpz_init(p0);

            //need to check allocation of tmp vars.  how big do they get?

            //1. s and t should be about half the bitlength of p
            //random s of bitlength bits/2
            s_len = (mp_bitcnt_t)(bits / 2 - 4);
            mpz_urandomb(s, gmp_randstate, s_len);
            mpz_setbit(s, s_len);

            //random t of bitlength bits/2
            mpz_urandomb(t, gmp_randstate, s_len);
            mpz_setbit(t, s_len);

            //2. Select an integer i0. Find the first prime in the sequence 2i(t) + 1, for i = i0; i0 +
            //1; i0 + 2; : : : (see Note 4.54). Denote this prime by r = 2i(t)+ 1.
            i = 1;
            mpz_mul_2exp(r, t, 1);
            mpz_add_ui(r, r, 1);
            while (mpz_probab_prime_p(r, 1) == 0)
            {
                i++;
                mpz_mul_2exp(r, t, 1);
                mpz_mul_ui(r, r, i);
                mpz_add_ui(r, r, 1);
                if (i > 10)
                    break;
            }

            //3. Compute p0 = 2(sr-2 mod r)s - 1.
            //zMul(&s, &r, &tmp);
            //zShortSub(&tmp, 2, &p0);
            //zDiv(&p0, &r, &tmp, &tmp2);
            //zMul(&tmp2, &s, &p0);
            //zShiftLeft(&p0, &p0, 1);
            //zShortSub(&p0, 1, &p0);
            mpz_mul(tmp, s, r);
            mpz_sub_ui(p0, tmp, 2);
            mpz_tdiv_r(tmp2, p0, r);
            mpz_mul(p0, tmp2, s);
            mpz_mul_2exp(p0, p0, 1);
            mpz_sub_ui(p0, p0, 1);

            //4. Select an integer j0. Find the first prime in the sequence p0 +2jrs, for j = j0; j0 +
            //1; j0 + 2; : : : (see Note 4.54). Denote this prime by p = p0 + 2jrs.
            j = 1;
            //zMul(&r, &s, &tmp);
            //zShiftLeft(&tmp, &tmp, 1);
            //zAdd(&p0, &tmp, p);
            mpz_mul(tmp, r, s);
            mpz_mul_2exp(tmp, tmp, 1);
            mpz_add(p, p0, tmp);
            while (mpz_probab_prime_p(p, 1) == 0)
            {
                j++;
                //zMul(&r, &s, &tmp);
                //zShiftLeft(&tmp, &tmp, 1);
                //zShortMul(&tmp, j, &tmp);
                //zAdd(&p0, &tmp, p);
                mpz_mul(tmp, r, s);
                mpz_mul_2exp(tmp, tmp, 1);
                mpz_mul_ui(tmp, tmp, j);
                mpz_add(p, p0, tmp);
                if (j > 10)
                    break;
            }

            mpz_clear(s);
            mpz_clear(t);
            mpz_clear(r);
            mpz_clear(tmp);
            mpz_clear(tmp2);
            mpz_clear(p0);
            return;
        }

        static Random rnd = new Random();
        static gmp_randstate_t? state;
        public static unsafe ulong Random64()
        {
            var low = rand.Next();
            var high = rand.Next();
            ulong result = (1ul << 63) | (uint)low | ((ulong)high) << 32;
            return result;
        }
        public static unsafe long Random63()
        {
            var low = rand.Next();
            long high = rand.Next();
            long result = (long)low | (high << 32);
            return result;
        }

        public static uint Random32()
        {
            var low = rand.Next();
            low = low | (1 << 31);
            return (uint)low;
        }
        public static int Random31()
        {
            var low = rand.Next();
            return low;
        }

        public static unsafe ulong Random64(int bits)
        {

            if (bits < 1 || bits > 63)
                throw new ArgumentException("Bits must be between 1 and 64");
            var buffer = new byte[bits >> 3];
            rnd.NextBytes(buffer);
            ref byte msb = ref buffer[bits >> 3];

            var shift = (1 << (bits & 7));
            var mask = (byte)shift - 1;
            msb = (byte)(msb & mask);
            msb = (byte)(msb | shift >> 1);

            ulong result = 0;
            fixed (byte* ptr = buffer)
            {
                result = *(ulong*)ptr;
            }

            return result;
        }

        public static GmpInt Rsa(int bits, TimeSpan? timeout = null)
        {
            if (timeout == null)
                timeout = TimeSpan.MaxValue;
            if (bits < 65)
                return PsuedoRsa(bits, timeout);
            if (bits < 36)
                return 0;
            mpz_t n = new();
            mpz_init_set_ui(n, 4096);

            build_RSA(bits, n, getRandomState(), timeout);
            gmp_lib.gmp_randclear(state);
            state = null;
            return n;
        }

        private static GmpInt PsuedoRsa(int bits, TimeSpan? timeout)
        {
            var sw = Stopwatch.StartNew();

            int actualBits = 0;
            GmpInt c = 0;

            while (actualBits != bits)
            {
                var a = GenerateRandomPrime((bits >> 1) + (bits & 1));
                var lena = a.BitLength;
                var b = GenerateRandomPrime(bits >> 1);
                var lenb = b.BitLength;
                c = a * b;
                actualBits = MathLib.BitLength(c);
                if (sw.Elapsed > timeout)
                {
                    Console.WriteLine($"Generate {nameof(PsuedoRsa)} timed out after {timeout}");
                }
            }
            return c;
        }

        private static GmpInt GenerateRandomSemiprime(int bits)
        {
            // Generate two random prime numbers
            GmpInt p = GenerateRandomPrime(bits / 2);
            GmpInt q = GenerateRandomPrime(bits / 2);

            // Compute the semiprime number
            GmpInt semiprime = p * q;

            return semiprime;
        }

        public static BigInteger GenerateRandomBigInt(int bits)
        {
            var randomBits = GenerateRandomBits(bits);

            BigInteger randomBig = new BigInteger(randomBits);
            return randomBig;
        }




        public static Func<int, uint[], BigInteger> BigIntFromBitsReflection = (sign, bits) =>
        {
            var ctors = typeof(BigInteger).GetConstructors(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            return (BigInteger)ctors[0].Invoke(new object[] { sign, bits });
        };


        public static Func<BigInteger, uint[]> BigIntGetBitsReflection = (src) =>
        {
            var getter = typeof(BigInteger).GetField("_bits", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            return (uint[])getter.GetValue( src);
        };


        private static Func<int, uint[], BigInteger> bigIntFromBitsCompiled = null!;
        public static Func<int, uint[], BigInteger> BigIntFromBits => bigIntFromBitsCompiled ??= CompileBigIntFromBitsConstructor();

        private static Func<int, uint[], BigInteger> CompileBigIntFromBitsConstructor()
        {
            Type bigIntegerType = typeof(BigInteger);
            Type[] parameterTypes = { typeof(int), typeof(uint[]) };
            ConstructorInfo? constructorInfo = typeof(BigInteger).GetConstructor(
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance,
                null,
                parameterTypes,
                null
            );
            if (constructorInfo == null)
                throw new Exception("Failed to find constructor BigInteger(int sign, uint[] bits)");

            ParameterExpression signParam = Expression.Parameter(typeof(int), "sign");
            ParameterExpression bitsParam = Expression.Parameter(typeof(uint[]), "bits");

            NewExpression constructorCall = Expression.New(constructorInfo, signParam, bitsParam);

            Expression<Func<int, uint[], BigInteger>> lambdaExpression = Expression.Lambda<Func<int, uint[], BigInteger>>(
                constructorCall,
                signParam,
                bitsParam
            );

            return lambdaExpression.Compile();
        }
        


        /// <summary>
        /// Construct a BigInteger from the bits in little-edian uint array (Msb = values[values.length-1) 
        /// </summary>
        /// <param name="values"></param>
        /// <returns></returns>
        public static BigInteger ToBigInteger(uint[] bits, int sign = 1)
        {
            if (bits.Length == 1) return new BigInteger(bits[0]);
            else
            {
                // direct constructor sets sign and bits directly using reflection.

                /*
                var ctors = typeof(BigInteger).GetConstructors(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                var result = ctors[0].Invoke(new object[] { sign, bits });
                return (BigInteger)result;
                */

                /*
                // byte constructor performs numerous validations then reconstructs bits from the byte buffer manually using a loop.
                var buffer = new byte[values.Length * 4];
                Buffer.BlockCopy(values, 0, buffer, 0, buffer.Length);
                return new BigInteger(buffer);
                */

                // compiled linq expression that avoids slow reflection call or overhead of bytes[] constuctor.
                return BigIntFromBits(sign, bits);
            }
        }


        public static uint[] ToUintArray(BigInteger src)
        {
            if (src.Sign > 1)  return new uint[] { (uint)src.Sign };
            else if (src.IsZero || src.IsOne) return new uint[] { (uint)src.Sign };

            //can get the bits directly but then need to worry about handling the sign being packed.
            //BigInteger t = 1;
            //t <<= 32;
            //var bits = BigIntGetBitsReflection(t);

            var bytes = src.ToByteArray();
            var words = new uint[1 + (bytes.Length >> 2)];
            Buffer.BlockCopy(bytes, 0, words, 0, bytes.Length);
            return words;
        }

        public static GmpInt GenerateRandomPrime(int bits)
        {
            GmpInt result = 4;
            while (!result.IsProbablePrime())
            {
                var randomBits = GenerateRandomBits(bits);

                BigInteger randomBig = new BigInteger(randomBits);
                GmpInt randN = randomBig;
                result = randN.NextPrimeGMP();

                var bs = result.ToString(2);
                var len = bs.Length;
            }

            return result;

        }

        private static byte[] GenerateRandomBits(int bits)
        {
            RandomNumberGenerator rnd = RandomNumberGenerator.Create();
            var words = bits >> 3;
            byte[] bytes = new byte[words + 1];
            rnd.GetBytes(bytes);
            ref byte msb = ref bytes[words];

            var shift = (1 << (bits & 7));
            var mask = (byte)shift - 1;
            msb = (byte)(msb & mask);
            msb = (byte)(msb | shift >> 1);
            return bytes;

        }

        private static gmp_randstate_t getRandomState()
        {
            if (state != null)
                gmp_lib.gmp_randclear(state);

            state = new();
            gmp_lib.gmp_randinit_mt(state);

            var seed = rnd.Next();
            gmp_lib.gmp_randseed_ui(state, (uint)seed);
            return state;
        }
        static void build_RSA(int bits, mpz_t n, gmp_randstate_t gmp_randstate, TimeSpan? timeout = null)
        {
            if (timeout == null)
                timeout = TimeSpan.MaxValue;
            int i;

            mpz_t p = new();
            mpz_t q = new();

            mpz_init(p);
            mpz_init(q);

            var sw = Stopwatch.StartNew();
            if (bits < 36)
            {
                //printf("bitlength too small\n");
                mpz_set_si(n, 0);
                return;
            }

            i = 0;
            int size = (int)mpz_sizeinbase(n, 2);
            while (size != bits)
            {
                gordon(bits / 2, p, gmp_randstate);
                gordon(bits / 2, q, gmp_randstate);
                mpz_mul(n, p, q);
                size = (int)mpz_sizeinbase(n, 2);
                i++;
                if (i > 10)
                {
                    gmp_randstate = getRandomState();
                }
                if (sw.Elapsed > timeout)
                {
                    Console.WriteLine($" => Rsa({bits}) timed out after {sw.Elapsed}");
                    break;
                }
            }

            mpz_clear(p);
            mpz_clear(q);
            return;
        }
    }
}